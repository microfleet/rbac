# RBAC design goals

RBAC service provides primitives for setting up permissions, roles, dynamic permission
lists registration

## Packages

### @microfleet/rbac-core

Contains persistence logic, data schema, CRUD operations
Basic primitives include `role` and `permission`

#### Schemas

Contains json schemas for models, input and associated responses

* [Role.json](../packages/rbac-core/schemas/Role.json)
* [Permission.json](../packages/rbac-core/schemas/Permission.json)
* [Inputs:](../packages/rbac-core/schemas/input)
  * [permissions.register](../packages/rbac-core/schemas/input/permissions.register.json)
* [Response:](../packages/rbac-core/schemas/response)
  * [permissions.register](../packages/rbac-core/schemas/response/permissions.register.json)

#### Operations

2 families of operations are available - `permissions` & `roles`

##### Permissions

Provides basic building blocks for roles to be created upon.
Permissions generally should not be deleted as roles rely heavily upon
their existence. Instead they should be deprecated. It is also important
to understand that there are reserved permissions which would work by default
on new services, which create new permission levels.

Generally permission is a string with the following semantics:

`<service-name>.<feature>[.<optional subfeature>].<type>`

Each of them in detail:

* `service-name` - unique service name across the system
* `feature` - granular routing prefix, for which the permission is applied
* `subfeature` - optional, could be multiple of them, for flexible granularity
* `type` - for wildcard permissions, could be anything, but generally expected to be one of:
  * `read`
  * `write`
  * `delete`

General convention:

* if `role` has access to `<service-name>` it can do everything
* `<service-name>.<feature>` - it can do everything on that feature (admin)
* `<service-name>.<feature>.read` - it can only read
* `<service-name>.<feature>.write` - it can create and update
* `<service-name>.<feature>.delete` - it can delete

That list can be structured for any business need, and commons, such as `read`, `write` & `delete` are
not obligatory to follow

###### permissions.register

Pass permission object to register or update it in the system. Generally services will be doing
that every time they startup. Update will be ignored if version in the system is higher that the
requested update

###### permissions.unregister

Discouraged to be called, but if some permission or service is no longer completely used in the system - can erase it

###### permissions.read

Returns information on 1 specific permission

###### permissions.list

Returns list of permissions that can be used. Supports iteration via cursors

##### Roles

Roles are end-user primitives. They combine sets of permissions and are used to eventually verify access to
resources. Role <-> users have many to many relations. One role can contain many permissions

###### roles.read

Returns information on 1 specific role and associated permissions

###### roles.create

Creates new role, `name` must be unique to avoid confusion

###### roles.update

Updates role

##### roles.delete

Removes role from the system. This requires one to be extra careful, because it needs to remove that role from all
associated resources (ie users). Shouldnt be done than at least somebody is using it. It's best to simply remove all
permissions associated with that role

##### roles.list

Returns list of roles, iterable via cursor
